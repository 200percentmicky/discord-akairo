"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Messages = {
    // Module-related
    FILE_NOT_FOUND: (filename) => `File '${filename}' not found`,
    MODULE_NOT_FOUND: (constructor, id) => `${constructor} '${id}' does not exist`,
    ALREADY_LOADED: (constructor, id) => `${constructor} '${id}' is already loaded`,
    NOT_RELOADABLE: (constructor, id) => `${constructor} '${id}' is not reloadable`,
    INVALID_CLASS_TO_HANDLE: (given, expected) => `Class to handle ${given} is not a subclass of ${expected}`,
    // Command-related
    ALIAS_CONFLICT: (alias, id, conflict) => `Alias '${alias}' of '${id}' already exists on '${conflict}'`,
    // Options-related
    COMMAND_UTIL_EXPLICIT: "The command handler options `handleEdits` and `storeMessages` require the `commandUtil` option to be true",
    UNKNOWN_MATCH_TYPE: (match) => `Unknown match type '${match}'`,
    // Generic errors
    NOT_INSTANTIABLE: (constructor) => `${constructor} is not instantiable`,
    NOT_IMPLEMENTED: (constructor, method) => `${constructor}#${method} has not been implemented`,
    INVALID_TYPE: (name, expected, vowel = false) => `Value of '${name}' was not ${vowel ? "an" : "a"} ${expected}`
};
/**
 * Represents an error for Akairo.
 * @param key - Error key.
 * @param args - Arguments.
 */
class AkairoError extends Error {
    constructor(key, ...args) {
        if (Messages[key] == null)
            throw new TypeError(`Error key '${key}' does not exist`);
        const message = typeof Messages[key] === "function"
            ? Messages[key](...args)
            : Messages[key];
        super(message);
        this.code = key;
    }
    /**
     * The error code.
     */
    code;
    /**
     * The error name.
     */
    get name() {
        return `AkairoError [${this.code}]`;
    }
}
exports.default = AkairoError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWthaXJvRXJyb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbC9Ba2Fpcm9FcnJvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE1BQU0sUUFBUSxHQUFHO0lBQ2hCLGlCQUFpQjtJQUNqQixjQUFjLEVBQUUsQ0FBQyxRQUFhLEVBQUUsRUFBRSxDQUFDLFNBQVMsUUFBUSxhQUFhO0lBQ2pFLGdCQUFnQixFQUFFLENBQUMsV0FBZ0IsRUFBRSxFQUFPLEVBQUUsRUFBRSxDQUMvQyxHQUFHLFdBQVcsS0FBSyxFQUFFLGtCQUFrQjtJQUN4QyxjQUFjLEVBQUUsQ0FBQyxXQUFnQixFQUFFLEVBQU8sRUFBRSxFQUFFLENBQzdDLEdBQUcsV0FBVyxLQUFLLEVBQUUscUJBQXFCO0lBQzNDLGNBQWMsRUFBRSxDQUFDLFdBQWdCLEVBQUUsRUFBTyxFQUFFLEVBQUUsQ0FDN0MsR0FBRyxXQUFXLEtBQUssRUFBRSxxQkFBcUI7SUFDM0MsdUJBQXVCLEVBQUUsQ0FBQyxLQUFVLEVBQUUsUUFBYSxFQUFFLEVBQUUsQ0FDdEQsbUJBQW1CLEtBQUsseUJBQXlCLFFBQVEsRUFBRTtJQUU1RCxrQkFBa0I7SUFDbEIsY0FBYyxFQUFFLENBQUMsS0FBVSxFQUFFLEVBQU8sRUFBRSxRQUFhLEVBQUUsRUFBRSxDQUN0RCxVQUFVLEtBQUssU0FBUyxFQUFFLHdCQUF3QixRQUFRLEdBQUc7SUFFOUQsa0JBQWtCO0lBQ2xCLHFCQUFxQixFQUNwQiwyR0FBMkc7SUFDNUcsa0JBQWtCLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRSxDQUFDLHVCQUF1QixLQUFLLEdBQUc7SUFFbkUsaUJBQWlCO0lBQ2pCLGdCQUFnQixFQUFFLENBQUMsV0FBZ0IsRUFBRSxFQUFFLENBQUMsR0FBRyxXQUFXLHNCQUFzQjtJQUM1RSxlQUFlLEVBQUUsQ0FBQyxXQUFnQixFQUFFLE1BQVcsRUFBRSxFQUFFLENBQ2xELEdBQUcsV0FBVyxJQUFJLE1BQU0sMkJBQTJCO0lBQ3BELFlBQVksRUFBRSxDQUFDLElBQVMsRUFBRSxRQUFhLEVBQUUsS0FBSyxHQUFHLEtBQUssRUFBRSxFQUFFLENBQ3pELGFBQWEsSUFBSSxhQUFhLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksUUFBUSxFQUFFO0NBQy9ELENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsTUFBcUIsV0FBWSxTQUFRLEtBQUs7SUFDN0MsWUFBbUIsR0FBVyxFQUFFLEdBQUcsSUFBMEI7UUFDNUQsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSTtZQUN4QixNQUFNLElBQUksU0FBUyxDQUFDLGNBQWMsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzFELE1BQU0sT0FBTyxHQUNaLE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFVBQVU7WUFDbEMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUN4QixDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNJLElBQUksQ0FBUztJQUVwQjs7T0FFRztJQUNILElBQW9CLElBQUk7UUFDdkIsT0FBTyxnQkFBZ0IsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDO0lBQ3JDLENBQUM7Q0FDRDtBQXhCRCw4QkF3QkMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNZXNzYWdlcyA9IHtcblx0Ly8gTW9kdWxlLXJlbGF0ZWRcblx0RklMRV9OT1RfRk9VTkQ6IChmaWxlbmFtZTogYW55KSA9PiBgRmlsZSAnJHtmaWxlbmFtZX0nIG5vdCBmb3VuZGAsXG5cdE1PRFVMRV9OT1RfRk9VTkQ6IChjb25zdHJ1Y3RvcjogYW55LCBpZDogYW55KSA9PlxuXHRcdGAke2NvbnN0cnVjdG9yfSAnJHtpZH0nIGRvZXMgbm90IGV4aXN0YCxcblx0QUxSRUFEWV9MT0FERUQ6IChjb25zdHJ1Y3RvcjogYW55LCBpZDogYW55KSA9PlxuXHRcdGAke2NvbnN0cnVjdG9yfSAnJHtpZH0nIGlzIGFscmVhZHkgbG9hZGVkYCxcblx0Tk9UX1JFTE9BREFCTEU6IChjb25zdHJ1Y3RvcjogYW55LCBpZDogYW55KSA9PlxuXHRcdGAke2NvbnN0cnVjdG9yfSAnJHtpZH0nIGlzIG5vdCByZWxvYWRhYmxlYCxcblx0SU5WQUxJRF9DTEFTU19UT19IQU5ETEU6IChnaXZlbjogYW55LCBleHBlY3RlZDogYW55KSA9PlxuXHRcdGBDbGFzcyB0byBoYW5kbGUgJHtnaXZlbn0gaXMgbm90IGEgc3ViY2xhc3Mgb2YgJHtleHBlY3RlZH1gLFxuXG5cdC8vIENvbW1hbmQtcmVsYXRlZFxuXHRBTElBU19DT05GTElDVDogKGFsaWFzOiBhbnksIGlkOiBhbnksIGNvbmZsaWN0OiBhbnkpID0+XG5cdFx0YEFsaWFzICcke2FsaWFzfScgb2YgJyR7aWR9JyBhbHJlYWR5IGV4aXN0cyBvbiAnJHtjb25mbGljdH0nYCxcblxuXHQvLyBPcHRpb25zLXJlbGF0ZWRcblx0Q09NTUFORF9VVElMX0VYUExJQ0lUOlxuXHRcdFwiVGhlIGNvbW1hbmQgaGFuZGxlciBvcHRpb25zIGBoYW5kbGVFZGl0c2AgYW5kIGBzdG9yZU1lc3NhZ2VzYCByZXF1aXJlIHRoZSBgY29tbWFuZFV0aWxgIG9wdGlvbiB0byBiZSB0cnVlXCIsXG5cdFVOS05PV05fTUFUQ0hfVFlQRTogKG1hdGNoOiBhbnkpID0+IGBVbmtub3duIG1hdGNoIHR5cGUgJyR7bWF0Y2h9J2AsXG5cblx0Ly8gR2VuZXJpYyBlcnJvcnNcblx0Tk9UX0lOU1RBTlRJQUJMRTogKGNvbnN0cnVjdG9yOiBhbnkpID0+IGAke2NvbnN0cnVjdG9yfSBpcyBub3QgaW5zdGFudGlhYmxlYCxcblx0Tk9UX0lNUExFTUVOVEVEOiAoY29uc3RydWN0b3I6IGFueSwgbWV0aG9kOiBhbnkpID0+XG5cdFx0YCR7Y29uc3RydWN0b3J9IyR7bWV0aG9kfSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWRgLFxuXHRJTlZBTElEX1RZUEU6IChuYW1lOiBhbnksIGV4cGVjdGVkOiBhbnksIHZvd2VsID0gZmFsc2UpID0+XG5cdFx0YFZhbHVlIG9mICcke25hbWV9JyB3YXMgbm90ICR7dm93ZWwgPyBcImFuXCIgOiBcImFcIn0gJHtleHBlY3RlZH1gXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgZm9yIEFrYWlyby5cbiAqIEBwYXJhbSBrZXkgLSBFcnJvciBrZXkuXG4gKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWthaXJvRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdHB1YmxpYyBjb25zdHJ1Y3RvcihrZXk6IHN0cmluZywgLi4uYXJnczogKHN0cmluZyB8IGJvb2xlYW4pW10pIHtcblx0XHRpZiAoTWVzc2FnZXNba2V5XSA9PSBudWxsKVxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXJyb3Iga2V5ICcke2tleX0nIGRvZXMgbm90IGV4aXN0YCk7XG5cdFx0Y29uc3QgbWVzc2FnZSA9XG5cdFx0XHR0eXBlb2YgTWVzc2FnZXNba2V5XSA9PT0gXCJmdW5jdGlvblwiXG5cdFx0XHRcdD8gTWVzc2FnZXNba2V5XSguLi5hcmdzKVxuXHRcdFx0XHQ6IE1lc3NhZ2VzW2tleV07XG5cblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLmNvZGUgPSBrZXk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGVycm9yIGNvZGUuXG5cdCAqL1xuXHRwdWJsaWMgY29kZTogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUaGUgZXJyb3IgbmFtZS5cblx0ICovXG5cdHB1YmxpYyBvdmVycmlkZSBnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gYEFrYWlyb0Vycm9yIFske3RoaXMuY29kZX1dYDtcblx0fVxufVxuIl19