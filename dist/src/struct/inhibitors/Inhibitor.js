"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AkairoError_1 = __importDefault(require("../../util/AkairoError"));
const AkairoModule_1 = __importDefault(require("../AkairoModule"));
/**
 * Represents an inhibitor.
 * @param id - Inhibitor ID.
 * @param options - Options for the inhibitor.
 */
class Inhibitor extends AkairoModule_1.default {
    constructor(id, { category, reason = "", type = "post", priority = 0 } = {}) {
        super(id, { category });
        this.reason = reason;
        this.type = type;
        this.priority = priority;
    }
    /**
     * The priority of the inhibitor.
     */
    priority;
    /**
     * Reason emitted when command is inhibited.
     */
    reason;
    /**
     * The type of the inhibitor for when it should run.
     */
    type;
    /**
     * Checks if message should be blocked.
     * A return value of true will block the message.
     * If returning a Promise, a resolved value of true will block the message.
     * @param message - Message being handled.
     * @param command - Command to check.
     */
    /* eslint-disable func-names, @typescript-eslint/no-unused-vars */
    /* public exec(message: Message, command?: Command): boolean | Promise<boolean>; */
    exec(message, command) {
        throw new AkairoError_1.default("NOT_IMPLEMENTED", this.constructor.name, "exec");
    }
    /* eslint-enable func-names, @typescript-eslint/no-unused-vars */
    /**
     * Reloads the inhibitor.
     */
    reload() {
        return super.reload();
    }
    /**
     * Removes the inhibitor.
     */
    remove() {
        return super.remove();
    }
}
exports.default = Inhibitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5oaWJpdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3N0cnVjdC9pbmhpYml0b3JzL0luaGliaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLHlFQUFpRDtBQUlqRCxtRUFBb0U7QUFJcEU7Ozs7R0FJRztBQUNILE1BQThCLFNBQVUsU0FBUSxzQkFBWTtJQUMzRCxZQUFtQixFQUFVLEVBQUUsRUFBRSxRQUFRLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsTUFBTSxFQUFFLFFBQVEsR0FBRyxDQUFDLEtBQXVCLEVBQUU7UUFDM0csS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFckIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFFakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUSxDQUFTO0lBMkJ4Qjs7T0FFRztJQUNJLE1BQU0sQ0FBUztJQUV0Qjs7T0FFRztJQUNJLElBQUksQ0FBUztJQUVwQjs7Ozs7O09BTUc7SUFDSCxrRUFBa0U7SUFDbEUsbUZBQW1GO0lBQzVFLElBQUksQ0FBQyxPQUFnQyxFQUFFLE9BQWlCO1FBQzlELE1BQU0sSUFBSSxxQkFBVyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFDRCxpRUFBaUU7SUFFakU7O09BRUc7SUFDYSxNQUFNO1FBQ3JCLE9BQU8sS0FBSyxDQUFDLE1BQU0sRUFBZSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNhLE1BQU07UUFDckIsT0FBTyxLQUFLLENBQUMsTUFBTSxFQUFlLENBQUM7SUFDcEMsQ0FBQztDQUNEO0FBOUVELDRCQThFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiZGlzY29yZC5qc1wiO1xuaW1wb3J0IEFrYWlyb0Vycm9yIGZyb20gXCIuLi8uLi91dGlsL0FrYWlyb0Vycm9yXCI7XG5pbXBvcnQgQWthaXJvTWVzc2FnZSBmcm9tIFwiLi4vLi4vdXRpbC9Ba2Fpcm9NZXNzYWdlXCI7XG5pbXBvcnQgQ2F0ZWdvcnkgZnJvbSBcIi4uLy4uL3V0aWwvQ2F0ZWdvcnlcIjtcbmltcG9ydCBBa2Fpcm9DbGllbnQgZnJvbSBcIi4uL0FrYWlyb0NsaWVudFwiO1xuaW1wb3J0IEFrYWlyb01vZHVsZSwgeyBBa2Fpcm9Nb2R1bGVPcHRpb25zIH0gZnJvbSBcIi4uL0FrYWlyb01vZHVsZVwiO1xuaW1wb3J0IENvbW1hbmQgZnJvbSBcIi4uL2NvbW1hbmRzL0NvbW1hbmRcIjtcbmltcG9ydCBJbmhpYml0b3JIYW5kbGVyIGZyb20gXCIuL0luaGliaXRvckhhbmRsZXJcIjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluaGliaXRvci5cbiAqIEBwYXJhbSBpZCAtIEluaGliaXRvciBJRC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGluaGliaXRvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgSW5oaWJpdG9yIGV4dGVuZHMgQWthaXJvTW9kdWxlIHtcblx0cHVibGljIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcsIHsgY2F0ZWdvcnksIHJlYXNvbiA9IFwiXCIsIHR5cGUgPSBcInBvc3RcIiwgcHJpb3JpdHkgPSAwIH06IEluaGliaXRvck9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKGlkLCB7IGNhdGVnb3J5IH0pO1xuXG5cdFx0dGhpcy5yZWFzb24gPSByZWFzb247XG5cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0dGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBwcmlvcml0eSBvZiB0aGUgaW5oaWJpdG9yLlxuXHQgKi9cblx0cHVibGljIHByaW9yaXR5OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFRoZSBjYXRlZ29yeSB0aGUgaW5oaWJpdG9yIGJlbG9uZ3MgdG8uXG5cdCAqL1xuXHRwdWJsaWMgZGVjbGFyZSBjYXRlZ29yeTogQ2F0ZWdvcnk8c3RyaW5nLCBJbmhpYml0b3I+O1xuXG5cdC8qKlxuXHQgKiBUaGUgQWthaXJvIGNsaWVudC5cblx0ICovXG5cdHB1YmxpYyBkZWNsYXJlIGNsaWVudDogQWthaXJvQ2xpZW50O1xuXG5cdC8qKlxuXHQgKiBUaGUgZmlsZXBhdGguXG5cdCAqL1xuXHRwdWJsaWMgZGVjbGFyZSBmaWxlcGF0aDogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5oaWJpdG9yIGhhbmRsZXIuXG5cdCAqL1xuXHRwdWJsaWMgZGVjbGFyZSBoYW5kbGVyOiBJbmhpYml0b3JIYW5kbGVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgSUQgb2YgdGhpcyBpbmhpYml0b3IuXG5cdCAqL1xuXHRwdWJsaWMgZGVjbGFyZSBpZDogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBSZWFzb24gZW1pdHRlZCB3aGVuIGNvbW1hbmQgaXMgaW5oaWJpdGVkLlxuXHQgKi9cblx0cHVibGljIHJlYXNvbjogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUaGUgdHlwZSBvZiB0aGUgaW5oaWJpdG9yIGZvciB3aGVuIGl0IHNob3VsZCBydW4uXG5cdCAqL1xuXHRwdWJsaWMgdHlwZTogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgbWVzc2FnZSBzaG91bGQgYmUgYmxvY2tlZC5cblx0ICogQSByZXR1cm4gdmFsdWUgb2YgdHJ1ZSB3aWxsIGJsb2NrIHRoZSBtZXNzYWdlLlxuXHQgKiBJZiByZXR1cm5pbmcgYSBQcm9taXNlLCBhIHJlc29sdmVkIHZhbHVlIG9mIHRydWUgd2lsbCBibG9jayB0aGUgbWVzc2FnZS5cblx0ICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIGJlaW5nIGhhbmRsZWQuXG5cdCAqIEBwYXJhbSBjb21tYW5kIC0gQ29tbWFuZCB0byBjaGVjay5cblx0ICovXG5cdC8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuXHQvKiBwdWJsaWMgZXhlYyhtZXNzYWdlOiBNZXNzYWdlLCBjb21tYW5kPzogQ29tbWFuZCk6IGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+OyAqL1xuXHRwdWJsaWMgZXhlYyhtZXNzYWdlOiBNZXNzYWdlIHwgQWthaXJvTWVzc2FnZSwgY29tbWFuZD86IENvbW1hbmQpOiBib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0dGhyb3cgbmV3IEFrYWlyb0Vycm9yKFwiTk9UX0lNUExFTUVOVEVEXCIsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCJleGVjXCIpO1xuXHR9XG5cdC8qIGVzbGludC1lbmFibGUgZnVuYy1uYW1lcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5cblx0LyoqXG5cdCAqIFJlbG9hZHMgdGhlIGluaGliaXRvci5cblx0ICovXG5cdHB1YmxpYyBvdmVycmlkZSByZWxvYWQoKTogSW5oaWJpdG9yIHtcblx0XHRyZXR1cm4gc3VwZXIucmVsb2FkKCkgYXMgSW5oaWJpdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGluaGliaXRvci5cblx0ICovXG5cdHB1YmxpYyBvdmVycmlkZSByZW1vdmUoKTogSW5oaWJpdG9yIHtcblx0XHRyZXR1cm4gc3VwZXIucmVtb3ZlKCkgYXMgSW5oaWJpdG9yO1xuXHR9XG59XG5cbi8qKlxuICogT3B0aW9ucyB0byB1c2UgZm9yIGluaGliaXRvciBleGVjdXRpb24gYmVoYXZpb3IuXG4gKiBBbHNvIGluY2x1ZGVzIHByb3BlcnRpZXMgZnJvbSBBa2Fpcm9Nb2R1bGVPcHRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluaGliaXRvck9wdGlvbnMgZXh0ZW5kcyBBa2Fpcm9Nb2R1bGVPcHRpb25zIHtcblx0LyoqXG5cdCAqIFJlYXNvbiBlbWl0dGVkIHdoZW4gY29tbWFuZCBvciBtZXNzYWdlIGlzIGJsb2NrZWQuXG5cdCAqL1xuXHRyZWFzb24/OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIENhbiBiZSAnYWxsJyB0byBydW4gb24gYWxsIG1lc3NhZ2VzLCAncHJlJyB0byBydW4gb24gbWVzc2FnZXMgbm90IGJsb2NrZWQgYnkgdGhlIGJ1aWx0LWluIGluaGliaXRvcnMsIG9yICdwb3N0JyB0byBydW4gb24gbWVzc2FnZXMgdGhhdCBhcmUgY29tbWFuZHMuXG5cdCAqIERlZmF1bHRzIHRvIGBwb3N0YFxuXHQgKi9cblx0dHlwZT86IFwiYWxsXCIgfCBcInByZVwiIHwgXCJwb3N0XCI7XG5cblx0LyoqXG5cdCAqIFByaW9yaXR5IGZvciB0aGUgaW5oaWJpdG9yIGZvciB3aGVuIG1vcmUgdGhhbiBvbmUgaW5oaWJpdG9ycyBibG9jayBhIG1lc3NhZ2UuXG5cdCAqIFRoZSBpbmhpYml0b3Igd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eSBpcyB0aGUgb25lIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGJsb2NrIHJlYXNvbi5cblx0ICogRGVmYXVsdHMgdG8gYDBgXG5cdCAqL1xuXHRwcmlvcml0eT86IG51bWJlcjtcbn1cbiJdfQ==